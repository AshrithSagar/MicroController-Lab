<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    <title>Experiment-7 | MicroController-Lab</title>
    <link rel="stylesheet" href="/MicroController-Lab/static/style.css">
    
</head>

<body>
    

<h1>Experiment-7</h1>


<h2>E7_X1.ASM</h2>
<code>
    
    ; Input two 2-digit HEX numbers from the keyboard. Display each

    <br>
    
    ; number in the data field and when NEXT key is pressed display

    <br>
    
    ; their product in the address field of the display.

    <br>
    
    

    <br>
    
    ; BIG ENDIAN CONVENTION FOR INPUTS,

    <br>
    
    ; OUTPUT IN LITTLE ENDIAN

    <br>
    
    

    <br>
    
    START:

    <br>
    
    	MOV R7, #02H 			; 7F 02 	; NUMBER OF INPUTS

    <br>
    
    

    <br>
    
    INPUT:

    <br>
    
    	LCALL RDKBD 			; 12 02 A2 	; READ FIRST NIBBLE

    <br>
    
    	SWAP A 					; C4 		; SWAP FOR PACKING

    <br>
    
    	MOV B, A 				; F5 F0 	; SAVE IN REG (B)

    <br>
    
    	LCALL RDKBD 			; 12 02 A2 	; READ SECOND NIBBLE

    <br>
    
    	ORL A, B 				; 45 F0 	; PACK THE NUMBER

    <br>
    
    	PUSH ACC 				; C0 E0 	; SAVE A COPY OF THE INPUT IN STACK

    <br>
    
    	MOV 60H, A 				; F5 60 	; DISPLAY PLACEHOLDER

    <br>
    
    	MOV B, #00H 			; 75 F0 00 	; NO DOT IN DISPLAY; F0 00, NOT 00 F0

    <br>
    
    	LCALL UPDDT	 			; 12 01 9B 	; DISPLAY IN DATA FIELD

    <br>
    
    

    <br>
    
    	DJNZ R7, INPUT 			; DF _E9	; TAKE TWO INPUTS

    <br>
    
    

    <br>
    
    	LCALL RDKBD 			; 12 02 A2 	; READ FOR NEXT KEYPRESS

    <br>
    
    	CJNE A, #14H, START 	; B4 14 _E1 ; REPEAT PROGRAM, IF NOT PRESSED NEXT KEY

    <br>
    
    

    <br>
    
    	POP ACC					; D0 E0 	; GET SECOND NUMBER

    <br>
    
    	MOV B, A				; F5 F0 	; LOAD IN REG (B)

    <br>
    
    	POP ACC 				; D0 E0 	; GET FIRST NUMBER

    <br>
    
    	MUL AB 					; A4 		; MULTIPLY THE INPUTS

    <br>
    
    

    <br>
    
    	MOV 60H, A 				; F5 60 	; FOR DISPLAYING LOWER NIBBLE OF PRODUCT

    <br>
    
    	MOV 61H, B				; 85 F0 61 	; FOR DISPLAYING UPPER NIBBLE OF PRODUCT

    <br>
    
    	MOV B, #00H 			; 75 F0 00 	; NO DOT IN DISPLAY

    <br>
    
    	LCALL CLEAR 			; 12 01 70 	; CLEAR UTILITY ROUTINE

    <br>
    
    	LCALL UPDAD				; 12 02 0B 	; DISPLAY IN ADDRESS FIELD

    <br>
    
    

    <br>
    
    	LJMP START 				; 12 80 00 	; REPEAT THE PROGRAM

    <br>
    
    

    <br>
    
    RDKBD:

    <br>
    
    	RET

    <br>
    
    UPDDT:

    <br>
    
    	RET

    <br>
    
    UPDAD:

    <br>
    
    	RET

    <br>
    
</code>

<h2>E7_X2.ASM</h2>
<code>
    
    ; Input a 4-digit HEX address of a memory location from

    <br>
    
    ; the keyboard and display its content in the data field

    <br>
    
    ; of the display when “NEXT” key is pressed.

    <br>
    
    

    <br>
    
    ; LITTLE ENDIAN CONVENTION

    <br>
    
    

    <br>
    
    START:

    <br>
    
    	MOV R0, #04H 				; 78 04 	; REPEAT COUNT

    <br>
    
    	INPUT:

    <br>
    
    		LCALL RDKBD 	 		; 12 02 A2 	; READ KEYBOARD

    <br>
    
    		PUSH ACC  				; C0 E0 	; SAVE INPUT CHARACTER

    <br>
    
    		DJNZ R0, INPUT 			; D8 _F9 	; REPEAT IN A LOOP

    <br>
    
    

    <br>
    
    		LCALL RDKBD				; 12 02 A2 	; CHECK FOR NEXT KEY PRESS

    <br>
    
    		CJNE A, #14H, START 	; B4 14 _F1	; BREAK OUT IF NEXT KEY NOT PRESSED

    <br>
    
    

    <br>
    
    	MOV R0, #83H 				; 78 83 	; TO PACK DATA TO (DPH, DPL)

    <br>
    
    	PACK:

    <br>
    
    		POP ACC  				; D0 E0 	; GET HIGHER NIBBLE

    <br>
    
    		SWAP A 					; C4 		; SWAP TO ALLOW FOR PACKING DATA

    <br>
    
    		MOV @R0, A 				; F6 		; MOVE TO DESTINATION (DP_)

    <br>
    
    

    <br>
    
    		POP ACC 				; D0 E0 	; GET LOWER NIBBLE

    <br>
    
    		ORL A, @R0				; 46 		; PACK THE DATA, STORE IN ACCUMULATOR

    <br>
    
    		MOV @R0, A 				; F6	 	; MOVE TO DESTINATION (DP_)

    <br>
    
    

    <br>
    
    		DEC R0 					; 18 		; DECREMENT TO POINT TO PREVIOUS ADDRESS

    <br>
    
    		CJNE @R0, #81H, PACK 	; B6 81 _F4	; CHECK IF DONE TWICE? FOR (DPH, DPL)

    <br>
    
    

    <br>
    
    	MOVX A, @DPTR 				; E0 		; GET DATA FROM INPUTTED LOCATION

    <br>
    
    	MOV 60H, A 					; F5 60  	; DISPLAY PLACEHOLDER

    <br>
    
    	LCALL UPDDT 				; 12 01 9B 	; DISPLAY ROUTINE

    <br>
    
    

    <br>
    
    RDKBD:

    <br>
    
    	RET

    <br>
    
    UPDDT:

    <br>
    
    	RET

    <br>
    
</code>

<h2>E7_X3.ASM</h2>
<code>
    
    ; Write an assembly language program to flash “SPICE” only

    <br>
    
    ; 10 times (display SPICE for 2 sec and blank for 1 sec).

    <br>
    
    

    <br>
    
    ; 8050H:

    <br>
    
    ; 37 60 93 97 00 00 D6

    <br>
    
    

    <br>
    
    ; 8000H:

    <br>
    
    MOV R0, #0AH 				; 78 0A 	; REPEAT COUNT

    <br>
    
    ITER:

    <br>
    
    	CLR PSW.5 				; C2 D5 	; LOAD FROM CODE MEMORY

    <br>
    
    	MOV DPTR, #8050H 		; 90 80 50 	; STARTING LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	LCALL OUTPUT 			; 12 02 55 	; OUTPUT UTILITY ROUTINE

    <br>
    
    	; DELAY FOR 2 SECONDS

    <br>
    
    	LCALL DELAY 			; 12 _A0 00

    <br>
    
    	LCALL DELAY 			; 12 _A0 00

    <br>
    
    

    <br>
    
    	LCALL CLEAR 			; 12 01 70 	; CLEAR UTILITY ROUTINE

    <br>
    
    	LCALL DELAY 			; 12 _A0 00 ; DELAY FOR 1 SECOND

    <br>
    
    

    <br>
    
    	DJNZ R0, ITER 			; D8 _EA	; REPEAT IN A LOOP

    <br>
    
    

    <br>
    
    	LCALL 0000H 			; 12 00 00 	; STOP EXECUTION

    <br>
    
    

    <br>
    
    ; A000H:

    <br>
    
    DELAY:

    <br>
    
    	; AWAIT (10H*0FAH*0FAH) MACHINE CYCLES =&gt; 1 SECOND

    <br>
    
    	MOV R3, #10H 			; 7B 10

    <br>
    
    	UP1:

    <br>
    
    		MOV R4, #0FAH 		; 7C FA

    <br>
    
    		UP2:

    <br>
    
    			MOV R5, #0FAH 	; 7D FA

    <br>
    
    		DJNZ R4, UP2 		; DC _FC

    <br>
    
    	DJNZ R3, UP1 			; DB _F8

    <br>
    
    	RET 					; 22 		; RETURN BACK TO THE MAIN LOOP

    <br>
    
    

    <br>
    
    CLEAR:

    <br>
    
    	RET

    <br>
    
    OUTPUT:

    <br>
    
    	RET

    <br>
    
</code>

<h2>E7_X4_1.ASM</h2>
<code>
    
    ; Roll “SPICE” continuously (a) left side (b) right side.

    <br>
    
    

    <br>
    
    ; 8050H:

    <br>
    
    ; 37 60 93 97 00 00 D6

    <br>
    
    

    <br>
    
    ; 8000H:

    <br>
    
    START:

    <br>
    
    	SETB PSW.5 				; D2 D5 	; LOAD FROM EXTERNAL DATA MEMORY

    <br>
    
    	MOV DPTR, #8050H 		; 90 80 50 	; STARTING LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	LCALL OUTPUT 			; 12 02 55 	; OUTPUT UTILITY ROUTINE

    <br>
    
    	LCALL DELAY 			; 12 _A0 00	; AWAIT

    <br>
    
    

    <br>
    
    	MOV DPTR, #8050H 		; 90 80 50 	; STARTING LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	MOVX A, @DPTR 			; E0 		; GET STARTING DATA, FOR LEFT ROTATE CASE

    <br>
    
    	MOV B, A 				; F5 F0 	; SAVE IN REG (B)

    <br>
    
    

    <br>
    
    	MOV R0, #07H 			; 78 07 	; REPEAT FOR 7 BYTES

    <br>
    
    

    <br>
    
    LEFT:

    <br>
    
    	INC DPTR 				; A3 		; GO TO NEXT LOCATION

    <br>
    
    	MOVX A, @DPTR 			; E0 		; GET DATA FROM NEXT LOCATION

    <br>
    
    	PUSH ACC 				; C0 E0 	; SAVE A COPY OF THE DATA IN STACK

    <br>
    
    

    <br>
    
    	; DECREMENT DATA POINTER AND GO TO CURRENT LOCATION

    <br>
    
    	CLR C 					; C3 		; CLEAR CARRY

    <br>
    
    	MOV A, 82H 				; E5 82  	; GET (DPL)

    <br>
    
    	SUBB A, #01H 			; 94 01 	; INCREMENT (DPL)

    <br>
    
    	MOV 82H, A 				; F5 82 	; SAVE (DPL)

    <br>
    
    

    <br>
    
    	MOV A, 83H 				; E5 83 	; GET (DPH)

    <br>
    
    	ADDC A, #00H 			; 34 00 	; ADD CARRY TO (DPH)

    <br>
    
    	MOV 83H, A 				; F5 83 	; SAVE (DPH)

    <br>
    
    

    <br>
    
    	POP ACC					; D0 E0 	; GET SAVED DATA

    <br>
    
     	MOVX @DPTR, A 			; F0 		; COPY DATA TO CURRENT LOCATION

    <br>
    
    

    <br>
    
     	INC DPTR 				; A3 		; UPDATE TO NEXT LOCATION

    <br>
    
    	DJNZ R0, LEFT 			; D8 _E9 	; REPEAT FOR ALL IN THE LOOK-UP TABLE

    <br>
    
    

    <br>
    
    	MOV DPTR, #8056H 		; 90 80 56 	; LAST LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	MOV A, B 				; E5 F0 	; GET STORED FIRST LOCATION DATA

    <br>
    
    	MOVX @DPTR, A 			; F0 		; STORE FIRST DATA IN LAST LOCATION

    <br>
    
    

    <br>
    
    	LJMP START 				; 02 80 00 	; REPEAT IN A LOOP

    <br>
    
    

    <br>
    
    ; A000H:

    <br>
    
    DELAY:

    <br>
    
    	; AWAIT (10H*0FAH*0FAH) MACHINE CYCLES =&gt; 1 SECOND

    <br>
    
    	MOV R3, #10H 			; 7B 10

    <br>
    
    	UP1:

    <br>
    
    		MOV R4, #0FAH 		; 7C FA

    <br>
    
    		UP2:

    <br>
    
    			MOV R5, #0FAH 	; 7D FA

    <br>
    
    		DJNZ R4, UP2 		; DC _FC

    <br>
    
    	DJNZ R3, UP1 			; DB _F8

    <br>
    
    	RET 					; 22 		; RETURN BACK TO THE MAIN LOOP

    <br>
    
    

    <br>
    
    OUTPUT:

    <br>
    
    	RET

    <br>
    
</code>

<h2>E7_X4_2.ASM</h2>
<code>
    
    ; Roll “SPICE” continuously (a) left side (b) right side.

    <br>
    
    

    <br>
    
    ; 8050H:

    <br>
    
    ; 37 60 93 97 00 00 D6

    <br>
    
    

    <br>
    
    ; 8000H:

    <br>
    
    START:

    <br>
    
    	SETB PSW.5 				; D2 D5 	; LOAD FROM EXTERNAL DATA MEMORY

    <br>
    
    	MOV DPTR, #8050H 		; 90 80 50 	; STARTING LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	LCALL OUTPUT 			; 12 02 55 	; OUTPUT UTILITY ROUTINE

    <br>
    
    	LCALL DELAY 			; 12 _A0 00	; AWAIT

    <br>
    
    

    <br>
    
    	MOV DPTR, #8056H 		; 90 80 50 	; LAST LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	MOVX A, @DPTR 			; E0 		; GET STARTING DATA, FOR LEFT ROTATE CASE

    <br>
    
    	MOV B, A 				; F5 F0 	; SAVE IN REG (B)

    <br>
    
    

    <br>
    
    	MOV R0, #07H 			; 78 07 	; REPEAT FOR 7 BYTES

    <br>
    
    

    <br>
    
    RIGHT:

    <br>
    
    	LCALL DEC_DPTR			; 12 90 00 	; DECREMENT DATA POINTER AND GO TO PREVIOUS LOCATION

    <br>
    
    

    <br>
    
    	MOVX A, @DPTR 			; E0 		; GET DATA FROM NEXT LOCATION

    <br>
    
    	INC DPTR 				; A3 		; GO TO NEXT LOCATION

    <br>
    
     	MOVX @DPTR, A 			; F0 		; COPY DATA TO CURRENT LOCATION

    <br>
    
    

    <br>
    
     	LCALL DEC_DPTR 			; 12 90 00 	; UPDATE TO CURRENT LOCATION

    <br>
    
    	DJNZ R0, RIGHT 			; D8 _F5 	; REPEAT FOR ALL IN THE LOOK-UP TABLE

    <br>
    
    

    <br>
    
    	MOV DPTR, #8050H 		; 90 80 56 	; STARTING LOCATION OF THE LOOK-UP TABLE

    <br>
    
    	MOV A, B 				; E5 F0 	; GET STORED FIRST LOCATION DATA

    <br>
    
    	MOVX @DPTR, A 			; F0 		; STORE FIRST DATA IN LAST LOCATION

    <br>
    
    

    <br>
    
    	LJMP START 				; 02 80 00 	; REPEAT IN A LOOP

    <br>
    
    

    <br>
    
    ; 9000H

    <br>
    
    DEC_DPTR:

    <br>
    
    	PUSH ACC 				; C0 E0 	; SAVE ACCUMULATOR

    <br>
    
    

    <br>
    
    	CLR C 					; C3 		; CLEAR CARRY

    <br>
    
    	MOV A, 82H 				; E5 82  	; GET (DPL)

    <br>
    
    	SUBB A, #01H 			; 94 01 	; INCREMENT (DPL)

    <br>
    
    	MOV 82H, A 				; F5 82 	; SAVE (DPL)

    <br>
    
    

    <br>
    
    	MOV A, 83H 				; E5 83 	; GET (DPH)

    <br>
    
    	ADDC A, #00H 			; 34 00 	; ADD CARRY TO (DPH)

    <br>
    
    	MOV 83H, A 				; F5 83 	; SAVE (DPH)

    <br>
    
    

    <br>
    
    	POP ACC 				; D0 E0 	; RETRIEVE ACCUMULATOR

    <br>
    
    	RET

    <br>
    
    

    <br>
    
    ; A000H:

    <br>
    
    DELAY:

    <br>
    
    	; AWAIT (10H*0FAH*0FAH) MACHINE CYCLES =&gt; 1 SECOND

    <br>
    
    	MOV R3, #10H 			; 7B 10

    <br>
    
    	UP1:

    <br>
    
    		MOV R4, #0FAH 		; 7C FA

    <br>
    
    		UP2:

    <br>
    
    			MOV R5, #0FAH 	; 7D FA

    <br>
    
    		DJNZ R4, UP2 		; DC _FC

    <br>
    
    	DJNZ R3, UP1 			; DB _F8

    <br>
    
    	RET 					; 22 		; RETURN BACK TO THE MAIN LOOP

    <br>
    
    

    <br>
    
    OUTPUT:

    <br>
    
    	RET

    <br>
    
</code>

<h2>README.md</h2>
<code>
    
    # Keyboard and Display programs

    <br>
    
    

    <br>
    
    ## Examples

    <br>
    
    

    <br>
    
    1. Read the key code of the key pressed and display the code in the data field of the display.

    <br>
    
    

    <br>
    
    2. Display HELLO in trainer display.

    <br>
    
    

    <br>
    
    3. Input a single digit decimal number through the key board and display its square value in the data field of the display.

    <br>
    
    

    <br>
    
    4. Display “SPICE UP” for 1 sec and blank for 2 sec.

    <br>
    
    

    <br>
    
    5. Flash “HELP” in the address field for 1 sec (1 sec HELP and blank for 1 sec).

    <br>
    
    

    <br>
    
    ## Exercises

    <br>
    
    

    <br>
    
    1. Input two 2-digit HEX numbers from the keyboard. Display each number in the data field and when NEXT key is pressed display their product in the address field of the display.

    <br>
    
    

    <br>
    
    2. Input a 4-digit HEX address of a memory location from the keyboard and display its content in the data field of the display when “NEXT” key is pressed.

    <br>
    
    

    <br>
    
    3. Write an assembly language program to flash “SPICE” only 10 times (display SPICE for 2 sec and blank for 1 sec).

    <br>
    
    

    <br>
    
    4. Roll “SPICE” continuously (a) left side (b) right side.

    <br>
    
    

    <br>
    
    ## Practice problems

    <br>
    
    

    <br>
    
    1. Input a 2-digit BCD number through the keyboard, convert BCD data into HEX, and display HEX equivalent in the data field if “C” key is pressed.

    <br>
    
    

    <br>
    
    2. Write a program to accept a 2 digit HEX number from the keyboard and on pressing “PREV” key display its square root if it is a perfect square, else display FFFF.

    <br>
    
    

    <br>
    
    3. Input a single digit number. If the number is zero, run a decimal up counter, if the number is 1 run a decimal down counter.

    <br>
    
    

    <br>
    
    4. Read two 4-digit HEX numbers from the keyboard, add them and flash the result in the display.

    <br>
    
</code>



</body>

</html>